import{a as s,A as c,M as g,U as m}from"./uf.service-Bn8JpA_W.js";class y{endpoint="/enderecos";async getAll(){try{const e=await s.get(this.endpoint);return new c(e.data).get()}catch{throw new Error("Erro ao buscar endereços")}}async getAllEnriched(e){try{console.log("🔍 AddressService.getAllEnriched - UF ID:",e);const[t,o,r]=await Promise.all([this.getAll(),g.getAll(),m.getAll()]);console.log("✅ AddressService dados:",{addresses:t.length,municipalities:o.length,ufs:r.length});const n=new Map(o.map(a=>[a.id,a])),i=new Map(r.map(a=>[a.id,a]));return t.filter(a=>e!=null?n.get(a.id_municipio)?.id_uf===e:!0).map(a=>{const l=n.get(a.id_municipio),p=l?i.get(l.id_uf):null;return{...a,municipio_nome:l?.nome,municipio_bairro:l?.bairro,municipio_id:l?.id,uf_sigla:p?.sigla,uf_nome:p?.nome,uf_id:p?.id}})}catch(t){throw console.error("Erro detalhado em AddressService.getAllEnriched:",t),new Error("Erro ao buscar endereços enriquecidos")}}async getById(e){return(await this.getAll()).find(o=>o.id===e)}async create(e){const t=await this.getAll(),o=t.length>0?Math.max(...t.map(n=>n.id))+1:1,r={...e,id:o};t.push(r);try{return await s.put(this.endpoint,new c(t).toNestedArray()),r}catch{throw new Error("Erro ao criar endereço")}}async update(e,t){const o=await this.getAll(),r=o.findIndex(d=>d.id===e);if(r===-1)throw new Error("Endereço não encontrado");const n=o[r];if(!n)throw new Error("Endereço não encontrado");const i={id:n.id,logradouro:t.logradouro??n.logradouro,numero:t.numero??n.numero,complemento:t.complemento??n.complemento,cep:t.cep??n.cep,id_municipio:t.id_municipio??n.id_municipio};o[r]=i;try{return await s.put(this.endpoint,new c(o).toNestedArray()),i}catch{throw new Error("Erro ao atualizar endereço")}}async delete(e){const o=(await this.getAll()).filter(r=>r.id!==e);try{await s.put(this.endpoint,new c(o).toNestedArray())}catch{throw new Error("Erro ao excluir endereço")}}}const h=new y;class E{endpoint="/localizacoes";async getAll(){try{const e=await s.get(this.endpoint);return new c(e.data).get()}catch{throw new Error("Erro ao buscar localizações")}}async getAllComplete(e){try{console.log("🔍 LocationService.getAllComplete - UF ID:",e);const[t,o,r]=await Promise.all([this.getAll(),_.getAllEnriched(e),h.getAllEnriched(e)]);console.log("✅ Dados carregados:",{locations:t.length,deposits:o.length,addresses:r.length});const n=new Map(o.map(a=>[a.id,a])),i=new Map(r.map(a=>[a.id,a]));return t.filter(a=>{const l=n.get(a.id_deposito);return l?e!=null?i.get(l.id_endereco)?.uf_id===e:!0:!1}).map(a=>{const l=n.get(a.id_deposito),p=l?i.get(l.id_endereco):null,u=[p?.uf_sigla,p?.municipio_nome,l?.nome,`${a.corredor}-${a.prateleira}-${a.secao}`].filter(Boolean).join(" / ");return{...a,deposito_nome:l?.nome,deposito_id:l?.id,endereco_completo:p?`${p.logradouro}, ${p.numero}${p.complemento?" - "+p.complemento:""}`:void 0,endereco_cep:p?.cep,endereco_id:p?.id,municipio_nome:p?.municipio_nome,municipio_bairro:p?.municipio_bairro,municipio_id:p?.municipio_id,uf_sigla:p?.uf_sigla,uf_nome:p?.uf_nome,uf_id:p?.uf_id,localizacao_completa:u}})}catch(t){throw console.error("Erro detalhado em getAllComplete:",t),new Error("Erro ao buscar localizações completas")}}async getById(e){return(await this.getAll()).find(o=>o.id===e)}async getByDeposit(e){return(await this.getAll()).filter(o=>o.id_deposito===e)}async create(e){const t=await this.getAll(),o=t.length>0?Math.max(...t.map(n=>n.id))+1:1,r={...e,id:o};t.push(r);try{return await s.put(this.endpoint,new c(t).toNestedArray()),r}catch{throw new Error("Erro ao criar localização")}}async update(e,t){const o=await this.getAll(),r=o.findIndex(d=>d.id===e);if(r===-1)throw new Error("Localização não encontrada");const n=o[r];if(!n)throw new Error("Localização não encontrada");const i={...n,...t,id:n.id};o[r]=i;try{return await s.put(this.endpoint,new c(o).toNestedArray()),i}catch{throw new Error("Erro ao atualizar localização")}}async delete(e){const o=(await this.getAll()).filter(r=>r.id!==e);try{await s.put(this.endpoint,new c(o).toNestedArray())}catch{throw new Error("Erro ao excluir localização")}}}class A{endpoint="/depositos";async getAll(){try{const e=await s.get(this.endpoint);return new c(e.data).get()}catch{throw new Error("Erro ao buscar depósitos")}}async getAllEnriched(e){try{const[t,o]=await Promise.all([this.getAll(),h.getAllEnriched(e)]),r=new Map(o.map(i=>[i.id,i]));return t.filter(i=>e!=null?r.get(i.id_endereco)?.uf_id===e:!0).map(i=>{const d=r.get(i.id_endereco);return{...i,endereco_completo:d?`${d.logradouro}, ${d.numero}${d.complemento?" - "+d.complemento:""}`:void 0,endereco_cep:d?.cep,municipio_nome:d?.municipio_nome,municipio_bairro:d?.municipio_bairro,uf_sigla:d?.uf_sigla,uf_nome:d?.uf_nome}})}catch(t){throw console.error("Erro detalhado em DepositService.getAllEnriched:",t),new Error("Erro ao buscar depósitos enriquecidos")}}async getById(e){return(await this.getAll()).find(o=>o.id===e)}async create(e){try{const t=await s.get(this.endpoint),o=new c(t.data).get(),r={id:Math.max(...o.map(n=>n.id),0)+1,...e};return o.push(r),await s.put(this.endpoint,new c(o).toNestedArray()),r}catch{throw new Error("Erro ao criar depósito")}}async update(e,t){try{const o=await s.get(this.endpoint),r=new c(o.data).get(),n=r.findIndex(a=>a.id===e);if(n===-1)throw new Error("Depósito não encontrado");const i=r[n],d={id:i.id,nome:t.nome??i.nome,id_endereco:t.id_endereco??i.id_endereco};return r[n]=d,await s.put(this.endpoint,new c(r).toNestedArray()),d}catch{throw new Error("Erro ao atualizar depósito")}}async delete(e){try{const t=await s.get(this.endpoint),r=new c(t.data).get().filter(n=>n.id!==e);await s.put(this.endpoint,new c(r).toNestedArray())}catch{throw new Error("Erro ao excluir depósito")}}}const B=new E,_=new A;class f{endpoint="/produtos";async getAll(){try{const e=await s.get(this.endpoint);return new c(e.data).get()}catch{throw new Error("Erro ao buscar produtos")}}async getAllEnriched(){try{const[e,t,o,r]=await Promise.all([this.getAll(),M.getAll(),S.getAll(),C.getAll()]),n=new Map(t.map(a=>[a.id,a])),i=new Map(o.map(a=>[a.id,a])),d=new Map(r.map(a=>[a.id,a]));return e.map(a=>{const l=n.get(a.id_categoria),p=i.get(a.id_marca),u=d.get(a.id_unidade_medida);return{...a,categoria_nome:l?.nome,marca_nome:p?.nome,unidade_abreviacao:u?.abreviacao,unidade_descricao:u?.descricao}})}catch{throw new Error("Erro ao buscar produtos enriquecidos")}}async getById(e){return(await this.getAll()).find(o=>o.id===e)}async create(e){const t=await this.getAll(),o=t.length>0?Math.max(...t.map(i=>i.id))+1:1,r=e.codigo&&e.codigo.trim()!==""?e.codigo:`PROD${o.toString().padStart(3,"0")}`,n={...e,id:o,codigo:r};t.push(n);try{return await s.put(this.endpoint,new c(t).toNestedArray()),n}catch{throw new Error("Erro ao criar produto")}}async update(e,t){const o=await this.getAll(),r=o.findIndex(d=>d.id===e);if(r===-1)throw new Error("Produto não encontrado");const n=o[r];if(!n)throw new Error("Produto não encontrado");const i={...n,...t,id:n.id};o[r]=i;try{return await s.put(this.endpoint,new c(o).toNestedArray()),i}catch{throw new Error("Erro ao atualizar produto")}}async delete(e){const o=(await this.getAll()).filter(r=>r.id!==e);try{await s.put(this.endpoint,new c(o).toNestedArray())}catch{throw new Error("Erro ao excluir produto")}}}class x{endpoint="/categorias";async getAll(){try{const e=await s.get(this.endpoint);return new c(e.data).get()}catch{throw new Error("Erro ao buscar categorias")}}async getById(e){try{return(await s.get(`${this.endpoint}/${e}`)).data}catch{throw new Error("Erro ao buscar categoria")}}async create(e){try{const t=await s.get(this.endpoint),o=new c(t.data).get(),r={id:Math.max(...o.map(n=>n.id),0)+1,...e};return o.push(r),await s.put(this.endpoint,new c(o).toNestedArray()),r}catch{throw new Error("Erro ao criar categoria")}}async update(e,t){try{const o=await s.get(this.endpoint),r=new c(o.data).get(),n=r.findIndex(a=>a.id===e);if(n===-1)throw new Error("Categoria não encontrada");const i=r[n],d={id:i.id,nome:t.nome??i.nome};return r[n]=d,await s.put(this.endpoint,new c(r).toNestedArray()),d}catch{throw new Error("Erro ao atualizar categoria")}}async delete(e){try{const t=await s.get(this.endpoint),r=new c(t.data).get().filter(n=>n.id!==e);await s.put(this.endpoint,new c(r).toNestedArray())}catch{throw new Error("Erro ao excluir categoria")}}}class v{endpoint="/marcas";async getAll(){try{const e=await s.get(this.endpoint);return new c(e.data).get()}catch{throw new Error("Erro ao buscar marcas")}}async getById(e){try{return(await s.get(`${this.endpoint}/${e}`)).data}catch{throw new Error("Erro ao buscar marca")}}async create(e){try{const t=await s.get(this.endpoint),o=new c(t.data).get();if(o.find(i=>i.nome.toLowerCase()===e.nome.toLowerCase()))throw new Error("Já existe uma marca com este nome");const n={id:Math.max(...o.map(i=>i.id),0)+1,...e};return o.push(n),await s.put(this.endpoint,new c(o).toNestedArray()),n}catch{throw new Error("Erro ao criar marca")}}async update(e,t){try{const o=await s.get(this.endpoint),r=new c(o.data).get(),n=r.findIndex(a=>a.id===e);if(n===-1)throw new Error("Marca não encontrada");if(t.nome&&r.find(l=>l.id!==e&&l.nome.toLowerCase()===t.nome.toLowerCase()))throw new Error("Já existe uma marca com este nome");const i=r[n],d={id:i.id,nome:t.nome??i.nome};return r[n]=d,await s.put(this.endpoint,new c(r).toNestedArray()),d}catch{throw new Error("Erro ao atualizar marca")}}async delete(e){try{const t=await s.get(this.endpoint),r=new c(t.data).get().filter(n=>n.id!==e);await s.put(this.endpoint,new c(r).toNestedArray())}catch{throw new Error("Erro ao excluir marca")}}}class b{endpoint="/unidade_medidas";async getAll(){try{const e=await s.get(this.endpoint);return new c(e.data).get()}catch{throw new Error("Erro ao buscar unidades de medida")}}async getById(e){try{return(await s.get(`${this.endpoint}/${e}`)).data}catch{throw new Error("Erro ao buscar unidade de medida")}}async create(e){try{const t=await s.get(this.endpoint),o=new c(t.data).get(),r={id:Math.max(...o.map(n=>n.id),0)+1,...e};return o.push(r),await s.put(this.endpoint,new c(o).toNestedArray()),r}catch{throw new Error("Erro ao criar unidade de medida")}}async update(e,t){try{const o=await s.get(this.endpoint),r=new c(o.data).get(),n=r.findIndex(a=>a.id===e);if(n===-1)throw new Error("Unidade de medida não encontrada");const i=r[n],d={id:i.id,descricao:t.descricao??i.descricao,abreviacao:t.abreviacao??i.abreviacao};return r[n]=d,await s.put(this.endpoint,new c(r).toNestedArray()),d}catch{throw new Error("Erro ao atualizar unidade de medida")}}async delete(e){try{const t=await s.get(this.endpoint),r=new c(t.data).get().filter(n=>n.id!==e);await s.put(this.endpoint,new c(r).toNestedArray())}catch{throw new Error("Erro ao excluir unidade de medida")}}}const z=new f,M=new x,S=new v,C=new b;export{S as B,M as C,_ as D,B as L,z as P,C as U};
